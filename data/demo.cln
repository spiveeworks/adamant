
// make a language as simple as possible
// (while still being usable at scale)
// feel like coding in C, but with the simplicity of LLVM
// maybe some basic quality of life like defer semantics

// implement self hosting as a measure of
// language's simplicity to use _and_ implement

/////////////////
// Type System //
/////////////////

//////////////////////////////
// basic types

my_void : b0 := 0;
my_bool : b1 := 1;
my_byte : b8 := 255;
my_short : b16 := my_byte * my_byte;
my_int : b32 := my_short * my_short;
my_long : b64 := my_int * my_int;

my_float : f32 := 1.0e38;
my_double : f64 := 1.0e308;

//////////////////////////////
// compound types

my_arr : [b8 * 8] := [0, 1, 2, 3, 4, 5, 6, 7];
my_tuple : {b8, b16} := {0, 0};
my_struct : {size : b8, max : b16} := {size := 0, max := 0};
// unions are kind of meaningless by value... but also inevitable
// scalar casting to union would be fine, but literals might be ambiguous
// could just use casting in all cases - much simpler
my_union : union {small : [b8 * 4], large : b32 } := union.small([0, 1, 2, 3]);
my_union_alt : union {small : [b8 * 4], large : b32 } := union.large(0);

//////////////////////////////
// pointer types

global_int : *b32 := global int;
global_bytes : *[b8 * 8] := global [b8 * 8];
global_struct : *{b8, b16} := global {b8, b16};
// pointer to union as well, if unions should exist at all...

//////////////////////////////
// type aliases

// no keyword needed, and capitalisation is just convention

Pair := {x: f64, y: f64};
String := {len: b64, data: *b8};

//////////////////////////////
// recursive types

// just like llvm

ListNode := {val: f64, next: *ListNode};
List1 := *ListNode;

List2 := *{val: f64, next: *\2};

Tree1 := {root: f64, len: b64, children: *[Tree1]};
Tree2 := {root: f64, len: b64, children: *[\3]};

// rules for unifying these could get complicated....
// here C is simpler, where structs are declared as uninitialized, whereas here
// we can initialize recursive structs with full type checking
// also interesting subtle things happen, like List1 and List2 above would be
// interchangeable, and expansions of either

PointerStream := *\1;
Indeterminant := \0;

///////////////
// Algorithm //
///////////////

//////////////////////////////
// Function basics

basics := (x : b32) -> b32 {
	return x * 2;
}

// structs are already so easy, but what if there was something even easier?
multiple_results := -> b32, b32 {
	return 0, 1;
}

intermediates := (a: f32, b: f32, c: f32) -> f32, f32 {
	delta := b * b - 4.0 * a * c
	near :=
		-b - sqrt(delta);
	far :=
		-b + sqrt(delta);
	return
		near / (2.0 * a),
		 far / (2.0 * a);
}

pointer_writes := (in: b32, out: *f32) -> {
	out <- f32(in) * 2.0;
}

locals := (val: b32) -> f32 {
	out := local f32;
	pointer_writes(val, out);
	return *out;
}

statics := -> {b32, *[b8]} {
	out := global [b8; 4] <- [0, 1, 2, 3];
	return {4, out as *[b8]};
}

control_flow := (scale: f32, len: b64, vals: *[f32]) -> {
	i := local b64 <- 0;
	while i < len {
		vals[i] <- scale * *vals[i];
	}
}

//////////////////////////////
// structural deref

field_value := (in: {x: b16, y: f32}) -> f32 {
	return in.y;
}
unnamed_fields := (in: {b16, f32}) -> b16, f32 {
	return in.x, in.y;
}
field_reborrow := (in: *{x: b16, y: f32}) -> *f32 {
	return in.y;
}
field_reborrow_multiple := (in: **{x: b16, y: f32}) -> *f32 {
	return in.y;
}
field_deref := (in: *{x: b16, y: f32}) -> f32 {
	return *in.y;
}

array_value := (in: [b8 * 4]) -> b8 {
	return in[3];
}
array_reborrow := (in: *[b8 * 4]) -> *b8 {
	return in[3];
}
array_reborrow_multiple := (in: **[b8 * 4]) -> *b8 {
	return in[3];
}
array_deref := (in: *[b8 * 4]) -> b8 {
	return *in[3];
}

reborrow_writing := (x: b16, y: f32) -> *{x: b16, y: f32} {
	out := global {x: b16, y: f32};
	out.0 <- x;
	out.1 <- y;
	return out;
}

//////////////////////////////
// heap

allocation_fixed_size := (len: b64, vals: *[f64]) -> *{f64, *\2} {
	root := local *{f64, *\2} <- null;
	current : **{f64, *\2} := root;
	i := local b64 <- 0;
	while i < len {
		*current <- alloc {f64, *\2};
		current.0 <- *vals[*i];
		current <- current.1;
		i <- + 1;
	}
	return root;
}

allocation_variable_size := (list: *{f64, *\2}) -> b64, *[f64] {
	len := local b64 <- 0;
	current := local *{f64, *\2} <- list;
	while *current {
		current <- *current.1;
		len <- + 1;
	}
	i := local b64 <- 0;
	out := alloc [f64 * len];
	current <- list;
	while i < len {
		out[*i] <- *current.0;
		i <- + 1;
	}
	return len, out;
}

reallocation := (len: b64, vals: *[f64]) -> *[f64] {
	out := realloc vals as [f64 * 2 * len];
	i := local b64 <- 0;
	while i < len {
		out[*i + len] <- out[*i];
		i <- + 1;
	}
}

freeing := (list: *{f64, *\2}) -> {
	current := local *{f64, *\2} <- list;
	while *current {
		next := *current.1;
		free *current;
		current <- next;
	}
}

//////////////////////////////
// untyped functions

// not sure about these right now...

untyped(x) -> {
	return x;
}

// the following is defined as untyped but can only be used as a specific set
// of overloads
as_b32 : b0 -> b32;
as_b32 : b1 -> b32;
as_b32 : b8 -> b32;
as_b32 : b16 -> b32;
as_b32 : b32 -> b32;
as_b32 : b68 -> b32;
as_b32 : [b8 * 4] -> b32;
as_b32(x) -> {
	return x as b32;
}

//////////////////////////////
// casts

convert_f_to_i := b32(1.5);
convert_i_to_f := f32(1);

convert_size_up := b32(b8(255)); // 255
convert_size_down := b8(b32(256)); // 0
convert_float_size_up := f64(f32(1.0));
convert_float_size_down := f32(f64(1.0));

implicit_upcast_int : b32 := b8(100);
implicit_upcast_float : f64 := f32(100);

reinterpret_f_to_i := 1.5 as b32; // not equal to 1!
reinterpret_i_to_f := 1 as f32; // not equal to 2.0!

reinterpret_array_pointer := global [b8 * 4] as *[b8];
implicit_array_pointer : *[b8] := global [b8 * 4];

//////////////////////////////
// advanced casts

compound : [b8 * 4] := [0, 1, 2, 3];
// note all of the following have stricter alignment requirements
reinterpret_compound := compound as b32;
reinterpret_c_to_c := compound as { b16, b8, b8 };
reinterpret_exotic_a := compound as [[b8 * 2] * 2];
reinterpret_exotic_b := compound as [b16 * 2];
reinterpret_exotic_c := compound as { [b8 * 2], [b16 * 1] };

reinterpret_pointer := global b32 as *[b8];
reinterpret_p_to_b := global { b1, [b8 * 17] } as b64;
reinterpret_b_to_p := 0 as *[b8];
// would be nice to have explicit features for this so that user doesn't make
// mistakes in all the repetition
reinterpret_substruct := (global {b8, b8, b16}).1 as *{b8, b16};
reinterpret_slice := (global [b8 * 8])[4] as *[b8];

//////////////////////////////
// dangerous casts

// no special syntax! always be careful with pointer casts
// even 'safe' casts above could be passed to functions that recast in
// dangerous ways, and hence aren't safe _at all_

reinterpret_misaligned := (global [b16 * 2])[2] as *b32;
// global and local memory are NOT guaranteed to be
// more aligned than necessary
reinterpret_misaligned_general := global b16 as *b32;
reinterpret_oversized := global [b8 * 4] as *[b8 * 5];


//////////////////////////////
// function pointers

// note a -> b is already a 'pointer to function'
// and *(a -> b) is in fact a pointer to a function pointer
// compatible with `val <- (x : A) -> B { ... };`
function_as_pointer := (x) -> {return x;} as *[b8];
pointer_as_function := global [b8 * 37] as (b32, b16) -> b16;
fishy_function_business := (x : [b8 * 4]) -> {return x[2]} as b32 -> b8;
// peak syntax
pointer_to_function_pointer := global b8 -> b8 <- (x) -> {return x;};
fp_in_struct : {b32, (b32, b8) -> b32} := {0, (x, y) -> {return x + y;}};
p2fp_in_struct : {b32, *(b8 -> b32)} := {0, global b8 -> b32};

