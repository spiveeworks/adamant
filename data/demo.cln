
// make a language as simple as possible
// (while still being usable at scale)
// feel like coding in C, but with the simplicity of LLVM

// implement self hosting as a measure of
// language's simplicity to use _and_ implement

// features that make it visibly clear how expensive
// operations are, not to encourage optimization, 
// but to encourage clear low level thinking

/////////////////
// Type System //
/////////////////

//////////////////////////////
// basic types

my_byte : b8 := 1 << 7;
my_short : b16 := 1 << 15;
my_int : b32 := 1 << 31;
my_long : b64 := 1 << 63;

// these types don't have full arithmetic so pointer
// manipulation is recommended
my_lllong : b128 = 999999999999999999999999999999;
// they are useful for specifying alignment though
my_cache_line : b1024 = 0;

my_signed : s32 := -2000;
my_unsigned : u32 := 60000 * 60000;
my_cyclic : c8 := -255; // equal to 1, no warnings etc.

my_float : f32 := 1.0e38;
my_double : f64 := 1.0e308;

my_ivector : s32x4 := my_lllong as s32x4;
my_vector : f32x4 := my_lllong as f32x4;

//////////////////////////////
// compound layouts

layout MyArray = [b8 * 8];
layout UnsizedLayout = [b8]; // or at least *[T] is valid
layout MyTuple = {b8, b16};
layout MyStruct = {size : b8, max : b16};
layout MyUnion = union {small : [b8 * 4], large : b32 };
layout MyScalar = b32;

// the main use of explicit layout names is recursion
layout MyList = {b64, *MyList};
layout Tree := {data: f64, len: b64, children: *[Tree]};

// cannot bind these to names, they only describe actual memory
// my_tuple : {b8, b16} := {0, 1};

layout Opaque;
layout OpaquePointer = *Opaque;
layout Opaque = {b32; *[OpaquePointer]};

//////////////////////////////
// pointer types

global_int : *s32 := global s32;
global_bytes : *[b8 * 8] := global [b8 * 8];
global_struct : *{b8, b16} := global {b8, b16};
global_pointer : **b8 := global *b8;
global_iterator : *[b8] := global_bytes; // coercing to forget size

///////////////
// Algorithm //
///////////////

//////////////////////////////
// Function basics

basics := (x : c32) -> c32 {
	return x * 2;
}

// we can't manipulate structs as values, so we just return 
// multiple scalars
multiple_results := -> b32, b32 {
	return 0, 1;
}

intermediates := (a: f32, b: f32, c: f32) -> f32, f32 {
	delta := b * b - 4.0 * a * c
	near :=
		-b - sqrt(delta);
	far :=
		-b + sqrt(delta);
	return
		near / (2.0 * a),
		 far / (2.0 * a);
}

pointer_writes := (in: b32, out: *f32) -> {
	out <- f32(in) * 2.0;
}

locals := (val: b32) -> f32 {
	out : *f32 := local f32;
	pointer_writes(val, out);
	return *out;
}

succinct_locals := -> f32 {
	local p1: b32 <- 100;
	pointer_writes(*p1, local p2: f32);
	return *p2;
}

statics := (x : b8) -> {b32, *[b8]} {
	out := global [b8; 4];
	out <- x, 1, x << 2, 3 | x;
	return {4, out as *[b8]};
}

control_flow := (scale: f32, len: u64, vals: *[f32]) -> {
	i := local u64 <- 0;
	while i < len {
		vals[i] <- scale * *vals[i];
	}
}

//////////////////////////////
// aggregate manipulation

field_reborrow := (in: *{x: b16, y: f32}) -> *f32 {
	return in.y;
}
field_reborrow_multiple := (in: **{x: b16, y: f32}) -> *f32 {
	return in.y;
}
unnamed_fields := (in: *{b16, f32}) -> *b16, *f32 {
	return in.0, in.1;
}
field_deref := (in: *{x: b16, y: f32}) -> f32 {
	return *in.y;
}
aggregate_deref_1 := (in: *{x: b16, y: f32}) -> b16, f32 {
	x, y := *in;
	return x, y;
}
aggregate_deref_2 := (in: *{x: b16, y: f32}) -> b16, f32 {
	return *in;
}

index := (in: *[b8 * 4]) -> *b8 {
	return in[3];
}
index_multiple := (in: **[b8 * 4]) -> *b8 {
	return in[3];
}
index_deref := (in: *[b8 * 4]) -> b8 {
	return *in[3];
}
array_deref := (in: *[b8 * 4]) -> b8, b8, b8, b8 {
	return *in;
}

field_writing := (x: b16, y: f32) -> *{x: b16, y: f32} {
	out := global {x: b16, y: f32};
	out.0 <- x;
	out.1 <- y;
	return out;
}
aggregate_writing := (x: b16, y: f32) -> *{x: b16, y: f32} {
	out := global {x: b16, y: f32};
	out <- x, y;
	return out;
}
multiple_results_write := (in: *{x: b16, y: f32}) -> *{b16, f32} {
	out := global {b16, f32};
	out <- aggregate_deref_1(in);
}
agg2agg := (in: *{x: b16, y: f32}) -> *{b16, f32} {
	out := global {b16, f32};
	out <- *in;
}

//////////////////////////////
// heap

layout List = {f64, *List};
allocation_fixed_size := (len: u64, vals: *[f64]) -> *List {
	root := local *List <- null;
	current : ***List := local **List <- root;
	i := local u64 <- 0;
	while i < len {
		*current <- alloc List;
		current.0 <- *vals[*i];
		current <- current.1;
		i <- *i + 1;
	}
	return *root;
}

allocation_variable_size := (list: *List) -> u64, *[f64] {
	len := local u64 <- 0;
	current := local *List <- list;
	while *current {
		current <- *current.1;
		len <- + 1;
	}
	i := local u64 <- 0;
	out := alloc f64 * len;
	current <- list;
	while *i < len {
		out[*i] <- *current.0;
		i <- *i + 1;
	}
	return len, out;
}

reallocation := (len: u64, vals: *[f64]) -> *[f64] {
	out := realloc vals as f64 * 2 * len;
	i := local u64 <- 0;
	while *i < len {
		out[*i + len] <- out[*i];
		i <- + 1;
	}
}

freeing := (list: *List) -> {
	current := local *List <- list;
	while *current {
		next := *current.1;
		free *current;
		current <- next;
	}
}

//////////////////////////////
// casts

convert_f_to_i := b32(1.5);
convert_i_to_f := f32(1);

convert_size_up := b32(b8(255)); // 255
convert_size_down := b8(b32(256)); // 0
convert_float_size_up := f64(f32(1.0));
convert_float_size_down := f32(f64(1.0));

implicit_upcast_int : b32 := b8(100);
implicit_upcast_float : f64 := f32(100);

reinterpret_f_to_i := 1.5 as b32; // not equal to 1!
reinterpret_i_to_f := 1 as f32; // not equal to 2.0!

reinterpret_array_pointer := global [b8 * 4] as *[b8];
implicit_array_pointer : *[b8] := global [b8 * 4];

//////////////////////////////
// advanced casts

compound : [b8 * 4] := [0, 1, 2, 3];
// note all of the following have stricter alignment requirements
reinterpret_compound := compound as b32;
reinterpret_c_to_c := compound as { b16, b8, b8 };
reinterpret_exotic_a := compound as [[b8 * 2] * 2];
reinterpret_exotic_b := compound as [b16 * 2];
reinterpret_exotic_c := compound as { [b8 * 2], [b16 * 1] };

reinterpret_pointer := global b32 as *[b8];
reinterpret_p_to_b := global { b1, [b8 * 17] } as b64;
reinterpret_b_to_p := 0 as *[b8];
// would be nice to have explicit features for this so that user doesn't make
// mistakes in all the repetition
reinterpret_substruct := (global {b8, b8, b16}).1 as *{b8, b16};
reinterpret_slice := (global [b8 * 8])[4] as *[b8];

//////////////////////////////
// dangerous casts

// no special syntax! always be careful with pointer casts
// even 'safe' casts above could be passed to functions that recast in
// dangerous ways, and hence aren't safe _at all_

reinterpret_misaligned := (global [b16 * 2])[2] as *b32;
// global and local memory are NOT guaranteed to be
// more aligned than necessary
reinterpret_misaligned_general := global b16 as *b32;
reinterpret_oversized := global [b8 * 4] as *[b8 * 5];


//////////////////////////////
// function pointers

// note a -> b is already a 'pointer to function'
// and *(a -> b) is in fact a pointer to a function pointer
// compatible with `val <- (x : A) -> B { ... };`
function_as_pointer := (x) -> {return x;} as *[b8];
pointer_as_function := global [b8 * 37] as (b32, b16) -> b16;
fishy_function_business := (x : [b8 * 4]) -> {return x[2]} as b32 -> b8;
// peak syntax
pointer_to_function_pointer := global b8 -> b8 <- (x) -> {return x;};
fp_in_struct : {b32, (b32, b8) -> b32} := {0, (x, y) -> {return x + y;}};
p2fp_in_struct : {b32, *(b8 -> b32)} := {0, global b8 -> b32};

