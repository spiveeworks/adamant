use super::*;
grammar;

pub Items: Vec<Item> = {
    Item*
};

Item: Item = {
    <name: Ident> "(" <params: Comma<Ascription>> ")" "->" <TypeExpr?>
        "{" <body: Statement*> "}"
            => Item::Function(name, Function { params, algorithm: body }),
    <Ident> ":=" <TypeExpr> ";" => Item::TypeDef(<>),
};

TypeExpr: TypeExpr = {
    "b8" => TypeExpr::Binary { bits: 8 },
    "b64" => TypeExpr::Binary { bits: 64 },
    "{" <fields: Comma<Ascription>> "}" => TypeExpr::Struct(fields.into_iter().collect()),
    "[" <inner: TypeExpr> "*" <size: Expr> "]" => TypeExpr::Array(Box::new(inner), Box::new(size)),
    "[" <inner: TypeExpr> "]" => TypeExpr::VarArray(Box::new(inner)),
    "*" <TypeExpr> => TypeExpr::Ptr(Box::new(<>)),
    <Ident> => TypeExpr::Ident(<>),
};

Statement: Statement = {
    <Ident> ":=" <Expr> ";" => Statement::Define(<>),
    <Expr> "<-" <Expr> ";" => Statement::Write(<>),
    <Expr> ";" => Statement::Discard(<>),
    "return" <Expr> ";" => Statement::Return(<>),
    "while" <Expr> "{" <Statement*> "}" => Statement::While(<>),
};

Expr = { ExprComparative };

ExprComparative: Expr = {
    <ExprAdditive> "<" <ExprAdditive> => Expr::LessThan(Box::new((<>))),
    ExprAdditive,
};

ExprAdditive: Expr = {
    // parse nested +s as the LHS so that execution is left to right
    <ExprAdditive> "+" <ExprIndirection> => Expr::Plus(Box::new((<>))),
    // also means a - b - c = (a - b) - c
    // instead of a - (b - c) which is actually a - b + c
    <ExprAdditive> "-" <ExprIndirection> => Expr::Minus(Box::new((<>))),
    ExprIndirection,
};

ExprIndirection: Expr = {
    "auto" <TypeExpr> => Expr::AutoAlloc(<>),
    "alloc" <TypeExpr> => Expr::GenAlloc(<>),
    "*" <ExprIndirection> => Expr::Deref(Box::new(<>)),
    StructureExpr,
};

StructureExpr: Expr = {
    <Ident> => Expr::Ident(<>),
    <data: StructureExpr> "." <field: Ident> => Expr::Field(Box::new(data), field),
    <StructureExpr> "[" <Expr> "]" => Expr::Index(Box::new((<>))),
    r"[0-9]*" => Expr::IntegerLiteral(<>.parse().unwrap()),
    "{" <vals: Comma<(<Ident> ":=" <Expr>)>> "}" =>
        Expr::StructLiteral(vals.into_iter().collect()),
    "[" <Comma<Expr>> "]" => Expr::ArrayLiteral(<>),
    <f: StructureExpr> "(" <args: Comma<Expr>> ")"
        => Expr::Call(Box::new(f), args),
    "(" <Expr> ")",
};

Ascription: (String, TypeExpr) = {
    <Ident> ":" <TypeExpr>,
};

Ident: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.into(),
};

// taken directly from
// http://lalrpop.github.io/lalrpop/tutorial/007_macros.html
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

